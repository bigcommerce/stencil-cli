#!/usr/bin/env node

require('colors');



var MAX_SIZE_COMPOSED = 1048576 * 2, //2MB
    MAX_SIZE_MOBILE = 1048576, //1MB
    MAX_SIZE_DESKTOP = 1048576 * 5, //5MB
    MAX_SIZE_BUNDLE = 1048576 * 50, //50MB
    WIDTH_COMPOSED = 600,
    HEIGHT_COMPOSED = 760,
    WIDTH_MOBILE = 304,
    HEIGHT_MOBILE = 540,
    WIDTH_DESKTOP = 2048,
    HEIGHT_DESKTOP = 2600,

    _ = require('lodash'),
    Archiver = require('archiver'),
    Async = require('async'),
    Validator = require('jsonschema').Validator,
    Crypto = require('crypto'),
    Fs = require('fs'),
    Jspm = require('jspm'),
    Path = require('path'),
    Program = require('commander'),
    CssAssembler = require('../lib/cssAssembler'),
    LangAssembler = require('../lib/langAssembler'),
    TemplateAssembler = require('../lib/templateAssembler'),
    ThemeConfig = require('../lib/themeConfig'),
    Tmp = require('tmp'),
    pkg = require('../package.json'),
    lwip = require('lwip'),
    themePath = process.cwd(),
    imagePath,
    imageTasks = [],
    tasks = {},
    templatesBasePath = Path.join(themePath, 'templates'),
    themeConfig,
    result,
    rawConfig,
    v = new Validator(),
    schema = Fs.readFileSync(Path.resolve(__dirname, '..', 'theme_config.json'), {encoding: 'utf-8'}),
    themeConfigPath = Path.join(themePath, 'config.json'),
    themeConfigExists = Fs.existsSync(themeConfigPath);

Program
    .version(pkg.version)
    .option('-d, --dest [dest]', 'Where to save the zip file. It defaults to the current directory you are in when bundling')
    .option('-n, --name  [filename]', 'What do you want to call the zip file. It defaults to stencil-bundle.zip')
    .option('-l, --lite', 'Only include the files necessary to run the theme on Bigcommerce. Do not include any templates, js, or scss source files.')
    .parse(process.argv);

if (Program.dest === true) {
    return console.error('Error: You have to specify a value for -d or --dest'.red);
}

if (Program.name === true) {
    return console.error('Error: You have to specify a value for -n or --name'.red);
}

if (! themeConfigExists) {
    return console.error('Error: You must have a '.red + 'config.json'.cyan + ' file in your top level theme directory.');
}


themeConfig = ThemeConfig.getInstance(themeConfigPath).getConfig();
rawConfig = JSON.parse(Fs.readFileSync(themeConfigPath, {encoding: 'utf-8'}));
tasks.css = getCssAssembleTask(themeConfig.css_compiler);
tasks.templates = assembleTemplatesTask;
tasks.lang = assembleLangTask;

console.log("Validating theme...");

if (themeConfig.jspm) {
    if (! Fs.existsSync(Path.join(themePath, themeConfig.jspm.jspm_packages_path))) {
        console.log('Error: The path you specified for your "jspm_packages" folder does not exist.'.red);
        return console.log(
            'Please check your '.red +
            'jspm.jspm_packages_path'.cyan +
            ' setting in your theme\'s '.red +
            'config.json'.cyan +
            ' file to make sure it\'s correct.'.red
        );
    }

    themeConfig.jspm.tmpBundleFile = Tmp.fileSync().name;
    tasks.jspmBundle = getJspmBundleTask(themeConfig.jspm);
}

if (!rawConfig.settings) {
    return console.error('Error: Your config.json is missing \'settings\' (object).'.red);
}

if (! Fs.existsSync(Path.join(themePath, 'schema.json'))) {
    return console.error('Error: Your theme is missing a \'schema.json\' file.'.red);
} else {
    try {
        JSON.parse(Fs.readFileSync(Path.join(themePath, 'schema.json'), {encoding: 'utf-8'}));
    } catch (e) {
        return console.error('Error: Your theme\'s schema.json file is not valid json'.red);
    }
}

// Validate against the theme registry config schema
schema = JSON.parse(schema);
result = v.validate(themeConfig, schema);

if (result.errors.length > 0) {
    console.error('Your theme\'s config.json has errors:'.red);
    result.errors.forEach(function(error ,index) {
        console.error(error.stack.red);
    });

    return;
}

// Do a bit of validation on the images

imagePath = Path.resolve(themePath, 'meta', themeConfig.meta.composed_image);
if (! Fs.existsSync(imagePath)) {
    return console.error('Error: The path you specified for your "meta.composed_image" folder does not exist.'.red);
} else {
    (function (path) {
        imageTasks.push(function (cb) {
            validateImage(path, 600, 760, cb);
        });
    }(imagePath));
}

for (var i = 0; i < themeConfig.variations.length; i++) {
    var variation = themeConfig.variations[i];
    var id = variation.id.blue;
    imagePath = Path.resolve(themePath, 'meta', variation.meta.desktop_screenshot);
    if (! Fs.existsSync(imagePath)) {
        return console.error('Error: The path you specified for the '.red + id + ' variation\'s "desktop_image" does not exist.'.red);
    } else {
        (function (path) {
            imageTasks.push(function (cb) {
                validateImage(path, 2048, 2600, cb);
            });
        }(imagePath));
    }

    imagePath = Path.resolve(themePath, 'meta', variation.meta.mobile_screenshot);
    if (! Fs.existsSync(imagePath)) {
        return console.error('Error: The path you specified for the '.red + id + ' variation\'s "mobile_screenshot" does not exist.'.red);
    } else {
        (function (path) {
            imageTasks.push(function (cb) {
                validateImage(path, 304, 540, cb);
            });
        }(imagePath));
    }
}

// First validate images, then we are good to process the bundle afterwards
Async.series([
    function(cb) {
        // Validate in parallel
        Async.parallel(imageTasks, function(err, result) {
            cb(err, result);
        });
    },
    function(cb) {
        Async.parallel(tasks, function (err, assembledData) {
            var outputFolder = Program.dest ? Program.dest : themePath,
                outputName = Program.filename ? Program.filename : 'stencil-bundle.zip',
                output = Fs.createWriteStream(Path.join(outputFolder, outputName)),
                pathsToZip = [
                    'assets/**/*',
                    'meta/**/*',
                    '!assets/jspm_packages/**', // Don't want jspm_packages if it's there
                    'templates/**/*',
                    'lang/*',
                    'README.md',
                    'CHANGELOG.md',
                    'config.json',
                    'package.json',
                    'schema.json'
                ],
                archive = Archiver('zip');

            if (err) {
                return console.error(err);
            }

            console.log('Zipping Files Started...');

            output.on('close', function () {
                console.log('ok'.green + ' -- Zipping Files Finished');
                console.log('Bundled saved to: ' + Path.join(outputFolder, outputName).cyan);

                var stats = Fs.statSync(Path.join(outputFolder, outputName));
                var size = stats['size'];

                if (size > MAX_SIZE_BUNDLE) {
                    return console.error('Error: Your bundle of size' + size
                        + 'bytes is above the max size of ' + MAX_SIZE_BUNDLE + 'bytes');
                }
            });


            if (Program.lite) {
                pathsToZip = pathsToZip.concat([
                    '!meta/**',
                    '!assets/js/**',
                    '!assets/scss/**',
                    '!templates/**',
                    '!lang/**'
                ])
            }

            archive.pipe(output);

            if (themeConfig.jspm) {
                archive.append(
                    Fs.createReadStream(themeConfig.jspm.tmpBundleFile),
                    {name: themeConfig.jspm.bundle_location}
                );
            }

            archive.bulk({
                src: pathsToZip,
                cwd: themePath,
                expand: true
            });

            Async.forEachOf(assembledData, function (data, type, callback) {
                if (type === 'css' || type === 'templates') {
                    Async.forEachOf(data, function (val, filename, forEachOfCallback) {
                        if (type === 'templates') {
                            filename = Crypto.createHash('md5').update(filename).digest('hex');
                            filename = Path.join('parsed', 'templates', filename + '.json');
                        } else {
                            filename = Path.join('parsed', 'scss', filename + '.json');
                        }
                        archive.append(JSON.stringify(val), {name: filename});
                        forEachOfCallback();
                    }, callback);
                } else {
                    if (type === 'lang') {
                        archive.append(JSON.stringify(data), {name: 'parsed/lang.json'});
                    }

                    callback();
                }
            }, function (err) {
                if (err) {
                    cb(err);
                }

                archive.finalize();
                cb(null, true);
            });
        });
    }
], function(err , result) {
    if (err) {
        return console.error(err.message.red);
    }
});

function validateImage(path, width, height, cb) {
    lwip.open(path, function(err, image) {
        if (err) {
            return cb(err);
        }

        var imageWidth = image.width();
        var imageHeight = image.height();
        var failureMessage = '';

        var stats = Fs.statSync(path);
        var size = stats['size'];

        if (width === WIDTH_DESKTOP && height === HEIGHT_DESKTOP && size > MAX_SIZE_DESKTOP) {
            failureMessage = 'Error: Image of size ' + size + ' bytes at path (' + path + ') '
            +  'is greater than allowed size ' + MAX_SIZE_DESKTOP + '\n';
        } else if (width === WIDTH_COMPOSED && height === HEIGHT_COMPOSED && size > MAX_SIZE_COMPOSED) {
            failureMessage = 'Error: Image of size ' + size + ' bytes at path (' + path + ') '
            +  'is greater than allowed size ' + MAX_SIZE_COMPOSED + '\n';
        } else if (width === WIDTH_MOBILE && height === HEIGHT_MOBILE && size > MAX_SIZE_MOBILE) {
            failureMessage = 'Error: Image of size ' + size + ' bytes at path (' + path + ') '
            +  'is greater than allowed size ' + MAX_SIZE_MOBILE + '\n';
        }

        if (imageWidth !== width || imageHeight != height) {
            failureMessage += 'Error: Image at (' + path + ') has incorrect dimensions ('
                + imageWidth + 'x' + imageHeight + ') should be' + '(' + width + 'x' + height + ')';
            return cb(new Error(failureMessage));
        }

        cb(null, true);
    });
}

function getCssAssembleTask(compiler) {
    return function (callback) {
        var basePath = Path.join(themePath, 'assets', compiler);
        console.log('%s Parsing Started...', compiler.toUpperCase());
        Fs.readdir(basePath, function (err, files) {
            files = files.filter(function (file) {
                return file.substr(-(compiler.length + 1)) === '.' + compiler;
            });

            Async.map(files, function (file, mapCallback) {
                CssAssembler.assemble(file, basePath, compiler, mapCallback);
            }, function (err, results) {
                var ret = {};

                if (err) {
                    return callback(err);
                }

                _.each(files, function (file, index) {
                    ret[file] = results[index];
                });

                console.log('ok'.green + ' -- %s Parsing Finished', compiler.toUpperCase());
                callback(null, ret);
            });
        });
    }
}

function assembleTemplatesTask(callback) {
    console.log('Template Parsing Started...');
    require('recursive-readdir')(templatesBasePath, function (err, files) {
        var replaceRegex = new RegExp('^' + templatesBasePath + '/(.*?)\.html$'),
            filesIn = [];

        //Prevent poorly named files breaking the regex (.DS_Store)
        files.forEach(function (fileName) {
            if (fileName.indexOf(".html") == fileName.length - 5) {
                filesIn.push(fileName);
            }
        });

        files = _.invoke(filesIn, 'replace', replaceRegex, '$1');
        Async.map(files, TemplateAssembler.assemble, function (err, results) {
            var ret = {};

            if (err) {
                return callback(err);
            }

            _.each(files, function (file, index) {
                ret[file] = results[index];
            });

            console.log('ok'.green + ' -- Template Parsing Finished');
            callback(null, ret);
        });
    });
}

function assembleLangTask(callback) {
    console.log('Language Files Parsing Started...');
    LangAssembler.assemble(function (err, results) {
        if (err) {
            return callback(err);
        }

        console.log('ok'.green + ' -- Language Files Parsing Finished');
        callback(null, results);
    });
}

function getJspmBundleTask(jspmConfig) {
    return function (callback) {
        var oldConsoleError = console.error;

        console.log('JavaScript Bundling Started...');

        // Need to suppress annoying errors from Babel.
        // They will be gone in the next minor version of JSPM (0.16.0).
        // Until then, this will stay in place
        console.error = function (error) {
            if (!/Deprecated option metadataUsedHelpers/.test(error)) {
                oldConsoleError(error);
            }
        };

        Jspm.setPackagePath(themePath);
        Jspm.bundleSFX(jspmConfig.bootstrap, jspmConfig.tmpBundleFile, {
            minify: true,
            mangle: true
        }).then(function () {
            console.log('ok'.green + ' -- JavaScript Bundling Finished');
            console.error = oldConsoleError;
            callback(null, true);
        });
    }
}

